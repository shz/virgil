extern {

  # Use of Browser/SugarJS Date
  struct Date {}
  function createDate(unixtime : int) : Date
  method isYesterday(input : Date) : bool
  method isToday(input : Date) : bool
  method format(input : Date, fmtstring : str) : str

  # Use of JS standard Math namespace
  function mathMax(x1 : float, x2 : float) : float
  function mathMin(x1 : float, x2 : float) : float
  function mathRound(x1 : float) : int

  method findIndex(haystack : list<int>, needle : int) : int
  method findIndex(haystack : list<float>, needle : float) : int
  method max(haystack : list<float>) : float
  method min(haystack : list<float>) : float
  method first(haystack : list<float>) : float
  method last(haystack : list<float>) : float


  function parseFloat(s:str) : float
}


# ********************************************
# The unanalyzed data coming from JAWS backend
#
extern {
  struct StockVizInputDataPoint {
    close : float
    time : int
  }
  struct StockVizInputMetadata {
    prev_close : float
    start_date : int
  }
  struct StockVizInput {
    values : list<StockVizInputDataPoint>
    meta : StockVizInputMetadata
  }
}

method mapForFloat(l : list<StockVizInputDataPoint>, mapfunc : func<StockVizInputDataPoint,float>) : list<float> {
  let ret : list<float> = []
  for i = 0 upto l.length {
    ret.push(mapfunc(l[i]))
  }
  return ret
}
method mapForInt(l : list<StockVizInputDataPoint>, mapfunc : func<StockVizInputDataPoint,int>) : list<int> {
  let ret : list<int> = []
  for i = 0 upto l.length {
    ret.push(mapfunc(l[i]))
  }
  return ret
}




# **************************************************
# The post-analysis data that goes to the viz engine
#
export struct Delta {
  absolute : float = 0
  perc : float = 0
}

export struct StockVizDriverData {
  dates : list<int> = null
  quotes : list<float> = null
  low : float = 0
  high : float = 0
  idxOfLow : int = 0
  idxOfHigh : int = 0
  span : float = 0
  priceStart : float = 0
  priceEnd : float = 0
  prevClose : float = 0
  netEffect : Delta = null
  lowGraphWindow : float = 0
  highGraphWindow : float = 0
  yUnitsPerRule : float = 0
  dateSemantic = ""
  dateRelDispl = ""
}




# ************************
# THE ANALYZER
#
export function analyze(input : StockVizInput) : StockVizDriverData {
  let data = new StockVizDriverData()

  data.dates = input.values.mapForInt(lambda(x:StockVizInputDataPoint) : int { return x.time })
  data.quotes = input.values.mapForFloat(lambda(x:StockVizInputDataPoint) : float { return x.close })

  # Find the low/high for the day (stock-price).
  data.low = data.quotes.min()
  data.high = data.quotes.max()

  data.priceStart = data.quotes.first()
  data.priceEnd = data.quotes.last()

  data.prevClose = input.meta.prev_close

  # // net gain/loss for the day
  data.netEffect = new Delta({
    absolute = data.priceEnd - data.prevClose
    perc = 100 * ((data.priceEnd - data.prevClose) / data.prevClose)
  })

  # Starting point for the y-axis window matches the low/high
  # data values but we will nudge those to provide some
  # breathing room.
  data.lowGraphWindow = mathMin(data.low, data.prevClose)
  data.highGraphWindow = mathMax(data.high, data.prevClose)

  # Is this a view of "today", "yesterday", or something in the past?
  let dateOfGraph = createDate(input.meta.start_date)
  let dateOfGraphStr = dateOfGraph.format("{Weekday} {Month} {dd}")
  let dateSemantic : Date = null
  if (dateOfGraph.isToday()) {
    data.dateSemantic = "Today"
  }
  else if (dateOfGraph.isYesterday()) {
    data.dateSemantic = "Yesterday"
  }

  data.dateRelDispl = dateOfGraphStr

  # Determine the array indexes that produced those highs/lows.
  data.idxOfLow = data.quotes.findIndex(data.low)
  data.idxOfHigh = data.quotes.findIndex(data.high)

  # This is the span of the graphwindow, not the actual high/low of stock price
  data.span = data.highGraphWindow - data.lowGraphWindow

  # Extend the vertical data "viewport" by 10% to include
  # some data that lies below the actual minimum,
  # so the trough of the graph doesn't actually hit
  # rock bottom.
  data.span = (1.1 * data.span).round()
  data.lowGraphWindow = data.highGraphWindow - data.span

  # Determine the Y-axis horiz-rule positioning.
  data.yUnitsPerRule = data.span / 5

  # Normalize the yUnitsPerRule
  if (data.yUnitsPerRule > 0.8) {
    data.yUnitsPerRule = mathRound(data.yUnitsPerRule)
  } else {
    for i=1 upto 10 {
      if (data.yUnitsPerRule.round() > 0) {
        data.yUnitsPerRule = data.yUnitsPerRule.round(i)
        break
      }
    }
  }

  return data
}

