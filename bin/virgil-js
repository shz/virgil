#!/usr/bin/env node

var fs = require('fs')
  , clc = require('cli-color')
  , vzs = require('../lib')
  ;

// TODO - Debug params
var options = {
  debug: false,
  module: false,
  node: false
};

var args = [];
for (var i=2; i<process.argv.length; i++) {
  var arg = process.argv[i];

  switch (arg) {
    case '-d':
    case '--debug':
      options.debug = true;
      break;

    case '-m':
    case '--module':
      options.module = true;
      break;

    case '--node':
      options.node = true;
      break;

    default:
      if (arg[0] == '-') {
        console.log('Unknown option', arg);
      } else {
        args.push(arg);
        break;
      }
    case '-h':
    case '--help':
      console.log('Usage: virgil-js [-d|--debug] [-m|--module [--node]] FILE');
      console.log('');
      process.exit(0);
      break;
  }
}

var highlight = function(line) {
  // Split line into comment and not comment
  var split = line.split('#');
  if (split.length > 1)
    split = [split[0], '#' + split.slice(1).join('#')];

  // Highlight keywords
  split[0] = split[0].replace(/\b(return)\b/g, function(s) {
    return clc.green(s);
  });

  // Highlight keywords 2
  split[0] = split[0].replace(/\b(true|false|let|mut|out|struct|function|method|if|else|for|upto|downto|while|export)\b/g, function(s) {
    return clc.cyan(s);
  });

  // Highlight type names
  split[0] = split[0].replace(/\b([A-Z][a-z0-9]*|int|float|str|list|func|void)\b/g, function(s) {
    return clc.magenta(s);
  });

  // Highlight operators
  split[0] = split[0].replace(/(\*|\*\*|\|\||\+|\-|\/|\=\=|\=|\%|\&\&|\<|\>)/g, function(s) {
    return clc.blue(s);
  });

  // Highlight strings
  split[0] = split[0].replace(/"[^\\"\r\n]*(?:\\.[^"\\]*)*"/g, function(s) {
    return clc.yellow(s);
  });

  // Fade back comments in a line a bit
  split[1] = clc.italic.blackBright(split[1]);

  return split.join('');
};

var printErrorContext = function(src, err) {
  var lines = src.split(/\r?\n/g);
  var start = Math.max(0, err.start.line - 3);
  var end = Math.min(lines.length, err.end.line + 2);
  var color = clc.red.bgWhite;

  var splitWhitespace = function(line) {
    var i = (line.match(/\S/) || {index: 0}).index;
    return [line.substr(0, i), line.substr(i)];
  };
  var lineHeader = function() {
    var base = null;
    if (lineNum >= err.start.line && lineNum <= err.end.line)
      base = color(lineNum + ':');
    else
      base = clc.blackBright(lineNum + ':');
    return base + ' ';
  };

  for (var i=start; i<end; i++) {
    var line = lines[i];
    var lineNum = i + 1;

    // Intermediate lines fully highlighted
    if (i+1 > err.start.line && i+1 < err.end.line) {
      var l = splitWhitespace(line);
      console.log(lineHeader() + l[0] + color(l[1]));

    // If the error is only on one line, special case
    } else if (i+1 == err.start.line && i+1 == err.end.line) {
      var t = lineHeader();
      t += highlight(line.substr(0, err.start.col));
      t += color(line.substring(err.start.col, err.end.col));
      t += highlight(line.substr(err.end.col));
      console.log(t);

    // Highlight leading portion
    } else if (i+1 == err.start.line) {
      var t = lineHeader();
      t += highlight(line.substr(0, err.start.col));
      t += color(line.substr(err.start.col));
      console.log(t);

    // Highlight trailing portion
    } else if (i+1 == err.end.line) {
      var t = lineHeader();
      var l = splitWhitespace(line.substr(0, err.end.col));
      t += l[0] + color(l[1]);
      t += highlight(line.substr(err.end.col));
      console.log(t);

    // Don't highlight anything else
    } else {
      console.log(lineHeader() + highlight(line));
    }
  }
};

fs.readFile(args[0], {encoding: 'utf8'}, function(err, src) {
  if (err) throw err;

  try {
    if (options.module) {
      var opts = {
        node: options.node,
        moduleName: args[0].replace(/\.vgl$/, '').replace(/[\/\\]/g, '.')
      };
      console.log(vzs.compileModule(src, 'javascript', opts));
    } else {
      console.log(vzs.compile(src, 'javascript'));
    }
  } catch (err) {
    // Attempt to pretty print errors
    if (err.start && !err.end) {
      err.end = {
        line: err.start.line,
        col: 1000
      };
      if (options.debug)
        console.log('Warning: No end marker for error');
    } else if (err.end && !err.start) {
      err.start = {
        line: err.end.line,
        col: 0
      };
      if (options.debug)
        console.log('Warning: No start marker for error');
    }
    if (err.start && err.end) {
      printErrorContext(src,err);
      console.log('');
    }

    // Log out the actual error source
    if (options.debug)
      console.log(err.stack);
    else
      console.log(err.message);

    process.exit(1);
  }
});

